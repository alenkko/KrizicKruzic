@page "/game/{numOfPlayers:int}/{symbolPlayerOne}"
@inject NavigationManager Navigation

<PageTitle>Krizic Kruzic</PageTitle>

<h2>On the move: @onTheMove @((onTheMove != symbolPlayerOne && numOfPlayers == 1) ? " (PC)" : "")</h2>
<h3>Score: @scorePlayerOne:@scorePlayerTwo</h3>
<table> 
    @for (int i = 0; i < 3; i++) {
        var row = i;
        <tr>
            @for (int j = 0; j < 3; j++) {
                var col = j;
                <td class="@(string.IsNullOrWhiteSpace(board[row, col]) ? "" : "clicked")" @onclick="() => Set(row, col)">
                    @board[row, col]
                </td>
            }
        </tr>
    }
</table>
<div class="buttons">
    <button @onclick="() => GoToMainMenu()">MAIN MENU</button>
</div>

@if (showAlert) {
    <div class="alertWindow">
        <p>@alertMessage</p>
        <button @onclick="ConfirmAlert">OK</button>
    </div>
}

@code {
    [Parameter]
    public int numOfPlayers { get; set; }   
    [Parameter]
    public required string symbolPlayerOne { get; set; }
    public required string onTheMove;
    public string? lastStart, alertMessage;
    bool isDraw = true, resetFinished = false, showAlert = false;
    public int scorePlayerOne = 0, scorePlayerTwo = 0;
    TaskCompletionSource<bool>? tcs;
    Random random = new();
    string[,] board = new string[3, 3];         

    protected override void OnParametersSet() {      //kada se prenesu parametri iz urla postave se varijable za praćenje poteza
        if (lastStart is null) {
            onTheMove = symbolPlayerOne;
            lastStart = symbolPlayerOne;
        }
    }
    void GoToMainMenu() {               //navigacija za main menu
        Navigation.NavigateTo("/");
    }
    async Task Set(int x, int y) {      //postavlja X ili O na odabrano polje i dalje daje PCju potez ako su zadovoljeni uvjeti
        if (string.IsNullOrWhiteSpace(board[x, y]) && (onTheMove == symbolPlayerOne || numOfPlayers == 2)) {
            board[x, y] = onTheMove;
            StateHasChanged();
            await CheckEndGame(x, y);

            if (resetFinished) {           
                resetFinished = false;
                return;
            }

            onTheMove = (onTheMove == "X") ? "O" : "X";

            if (numOfPlayers == 1 && onTheMove != symbolPlayerOne) await GiveTurnToPC();
        }
    }
    async Task GiveTurnToPC() {
        StateHasChanged();
        await Task.Delay(1000);
        await PCMove();
    }
    async Task Reset() {        //resetira polje i daje PCju prvi potez ako je on idući
        resetFinished = true;

        lastStart = (lastStart == "X") ? "O" : "X";
        onTheMove = lastStart;

        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) 
                board[i, j] = "";

        if (numOfPlayers == 1 && onTheMove != symbolPlayerOne) await GiveTurnToPC();
        StateHasChanged();
    }
    async Task PCMove() {                //PC nasumično odabire jedno od slobodnih polja za svoj potez
        List<(int x, int y)> remainingFields = new();
        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) {
                if (string.IsNullOrWhiteSpace(board[i, j])) remainingFields.Add((i, j));
            }

        if (remainingFields.Count > 0) {
            var (i, j) = remainingFields[random.Next(remainingFields.Count)];
            board[i, j] = onTheMove;
            StateHasChanged();
            await CheckEndGame(i, j);
            if (resetFinished) {
                resetFinished = false;
                return;
            }
            onTheMove = (onTheMove == "X") ? "O" : "X";
        }
    }
     async Task CheckEndGame(int x, int y) {             //provjera kraja igre po retcima, stupcima i dijagonalama
        string currentPlayer = board[x, y];
        if (string.IsNullOrWhiteSpace(currentPlayer)) return;

        if (board[x, 0] == currentPlayer && board[x, 1] == currentPlayer && board[x, 2] == currentPlayer) {      //redak
            await UpdateWinnerStats(currentPlayer);
            return;
        }

        if (board[0, y] == currentPlayer && board[1, y] == currentPlayer && board[2, y] == currentPlayer) {      //stupac
            await UpdateWinnerStats(currentPlayer);
            return;
        }

        if (x == y && board[0, 0] == currentPlayer && board[1, 1] == currentPlayer && board[2, 2] == currentPlayer) {    //glavna dijagonala
            await UpdateWinnerStats(currentPlayer);
            return;
        }

        if (x + y == 2 && board[0, 2] == currentPlayer && board[1, 1] == currentPlayer && board[2, 0] == currentPlayer) {    //sporedna dijagonala
            await UpdateWinnerStats(currentPlayer);
            return;
        }

        isDraw = true;           //ako je board cijeli ispunjen onda je neriješeno
        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) {
                if (string.IsNullOrWhiteSpace(board[i, j])) isDraw = false;
            }
            
        if (isDraw) {
            await ShowMessage("Draw!");
            await Reset();
            return;
        }
    }
    async Task UpdateWinnerStats(string winner) {       //metoda koja se zove kada je igra gotova
        await ShowMessage("Winner " + winner + "!");

        if (winner == symbolPlayerOne) scorePlayerOne++;
        else scorePlayerTwo++;

        await Reset();
    }
    async Task ShowMessage(string message) {    //prikazuje alert, zatim kreira novi TCS koji čeka dok se ne pritisne tipka OK, nakon toga skriva alert
        alertMessage = message;
        showAlert = true;
        StateHasChanged();

        tcs = new TaskCompletionSource<bool>();
        await tcs.Task;

        showAlert = false;
        StateHasChanged();
    }
    void ConfirmAlert() {       //na pritisak gumba oslobađamo izvođenje koda
        tcs?.SetResult(true);
    }
}


