@page "/game/{numOfPlayers:int}/{symbolPlayerOne}"

@inject IJSRuntime JS
@inject NavigationManager Navigation

<PageTitle>Krizic Kruzic</PageTitle>

<h2>On the move: @onTheMove @((onTheMove != symbolPlayerOne && numOfPlayers == 1) ? " (PC)" : "")</h2>
<h3>Score: @scorePlayerOne:@scorePlayerTwo</h3>
<table> 
    @for (int i = 0; i < 3; i++)
    {
        var row = i;
        <tr>
            @for (int j = 0; j < 3; j++)
            {
                var col = j;
                <td class="@(string.IsNullOrWhiteSpace(polje[row, col]) ? "" : "clicked")" @onclick="() => Set(row, col)">
                    @polje[row, col]
                </td>
            }
        </tr>
    }
</table>
<div class="buttons">
    <button @onclick="() => GoToMainMenu()">MAIN MENU</button>
</div>

@code {
    [Parameter]
    public int numOfPlayers { get; set; }   
    [Parameter]
    public required string symbolPlayerOne { get; set; }
    public required string onTheMove;
    public string? lastStart;
    bool checkFinished = true;
    bool resetFinished = false;

    public int scorePlayerOne = 0;
    public int scorePlayerTwo = 0;
    Random random = new();

    protected override void OnParametersSet()       //kada se prenesu parametri iz urla postave se varijable za praćenje poteza
    {
        if (lastStart is null)
        {
            onTheMove = symbolPlayerOne;
            lastStart = symbolPlayerOne;
        }
    }

    string[,] polje = new string[3, 3];         //polje koje predstavlja grid 

    void GoToMainMenu() {               //navigacija za main menu
        Navigation.NavigateTo("/");
    }

    async Task Set(int x, int y) {      //postavlja X ili O na odabrano polje i dalje daje PCju potez ako su zadovoljeni uvjeti
        if (string.IsNullOrWhiteSpace(polje[x, y]) && (onTheMove == symbolPlayerOne || numOfPlayers == 2)) {
            polje[x, y] = onTheMove;
            StateHasChanged();
            await Task.Delay(50);
            await checkEndGame();

            if (resetFinished) {           
                resetFinished = false;
                return;
            }

            onTheMove = (onTheMove == "X") ? "O" : "X";

            if (numOfPlayers == 1 && onTheMove != symbolPlayerOne) {
                StateHasChanged();
                await Task.Delay(1000);
                await PCMove();
            }
        }
    }

    async Task Reset() {        //resetira grid i daje PCju prvi potez ako je on idući
        resetFinished = true;

        if (lastStart == "X") {
            lastStart = "O";
            onTheMove = "O";
        } else {
            lastStart = "X";
            onTheMove = "X";
        }

        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) 
                polje[i, j] = "";

        if (numOfPlayers == 1 && onTheMove != symbolPlayerOne) {
            StateHasChanged();
            await Task.Delay(1000);
            await PCMove();
        }

        StateHasChanged();
    }

    async Task PCMove() {                //PC nasumično odabire jedno od slobodnih polja za svoj potez
        List<(int x, int y)> remainingFields = new();
        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) {
                if (string.IsNullOrWhiteSpace(polje[i, j])) remainingFields.Add((i, j));
            }

        if (remainingFields.Count > 0) {
            var (i, j) = remainingFields[random.Next(remainingFields.Count)];
            polje[i, j] = onTheMove;
            StateHasChanged();
            await Task.Delay(50);
            await checkEndGame();
            if (resetFinished) {
                resetFinished = false;
                return;
            }
            onTheMove = (onTheMove == "X") ? "O" : "X";
        }
    }

    async Task checkEndGame() {             //provjera kraja igre po retcima, stupcima i dijagonalama
        for (int i = 0; i < 3; i++)
        {
            if (!string.IsNullOrWhiteSpace(polje[i, 0]) && polje[i, 0] == polje[i, 1] && polje[i, 1] == polje[i, 2]) {
                await JS.InvokeVoidAsync("alert", "Winner " + polje[i, 0] + "!");
                if (polje[i, 0] == symbolPlayerOne) scorePlayerOne++;
                else {
                    scorePlayerTwo++;
                }
                await Reset();
                return;
            }
        }
        for (int i = 0; i < 3; i++)
        {
            if (!string.IsNullOrWhiteSpace(polje[0, i]) && polje[0, i] == polje[1, i] && polje[1, i] == polje[2, i]) {
                await JS.InvokeVoidAsync("alert", "Winner " + polje[0, i] + "!");
                if (polje[0, i] == symbolPlayerOne) scorePlayerOne++;
                else {
                    scorePlayerTwo++;
                }
                await Reset();
                return;
            }
        }
        if (!string.IsNullOrWhiteSpace(polje[0, 0]) && polje[0, 0] == polje[1, 1] && polje[2, 2] == polje[1,1]) {
            await JS.InvokeVoidAsync("alert", "Winner " + polje[0, 0] + "!");
            if (polje[0, 0] == symbolPlayerOne) scorePlayerOne++;
            else {
                scorePlayerTwo++;
            }
            await Reset();
            return;
        }
        if (!string.IsNullOrWhiteSpace(polje[0, 2]) && polje[0, 2] == polje[1, 1] && polje[2, 0] == polje[1,1]){
            await JS.InvokeVoidAsync("alert", "Winner " + polje[0, 2] + "!");
            if (polje[0, 2] == symbolPlayerOne) scorePlayerOne++;
            else {
                scorePlayerTwo++;
            }
            await Reset();
            return;
        }
        checkFinished = true;           //ako je grid cijeli ispunjen onda je neriješeno
        for (int i = 0; i < 3; i++) 
            for (int j = 0; j < 3; j++) {
                if (string.IsNullOrWhiteSpace(polje[i, j])) checkFinished = false;
            }
        if (checkFinished) {
            await JS.InvokeVoidAsync("alert", "Draw!");
            await Reset();
            return;
        }
        return;
    }
}


